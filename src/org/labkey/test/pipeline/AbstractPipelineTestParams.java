/*
 * Copyright (c) 2008-2019 LabKey Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.labkey.test.pipeline;

import org.apache.commons.lang3.StringUtils;
import org.labkey.test.BaseWebDriverTest;
import org.labkey.test.Locator;
import org.labkey.test.TestFileUtils;
import org.labkey.test.WebDriverWrapper;
import org.labkey.test.components.dumbster.EmailRecordTable;
import org.labkey.test.util.ExperimentRunTable;
import org.labkey.test.util.PasswordUtil;
import org.labkey.test.util.PipelineStatusTable;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

abstract public class AbstractPipelineTestParams implements PipelineTestParams
{
    protected PipelineWebTestBase _test;
    private String _dataPath;
    private String _protocolType;
    private String _parametersFile;
    private String _protocolName;
    private String[] _sampleNames;
    private String[] _inputExtensions = new String[0];
    private String[] _outputExtensions = new String[0];
    private String[] _experimentLinks;
    protected PipelineFolder.MailSettings _mailSettings;
    private boolean _expectError;    
    private boolean _valid;

    public AbstractPipelineTestParams(PipelineWebTestBase test, String dataPath,
                                      String protocolType, String protocolName, String... sampleNames)
    {
        _test = test;
        _dataPath = dataPath;
        _sampleNames = sampleNames;
        _protocolType = protocolType;
        _protocolName = protocolName;
        _valid = true;
    }

    @Override
    public PipelineWebTestBase getTest()
    {
        return _test;
    }

    @Override
    public String getDataPath()
    {
        return _dataPath;
    }

    public String getDataDirName()
    {
        String[] parts = StringUtils.split(_dataPath, '/');
        return parts[parts.length - 1]; 
    }

    @Override
    public String getProtocolName()
    {
        return _protocolName;
    }

    @Override
    public String getProtocolType()
    {
        return _protocolType;
    }

    @Override
    public String[] getSampleNames()
    {
        return _sampleNames;
    }

    @Override
    public String getParametersFile()
    {
        return _parametersFile != null ? _parametersFile : _protocolType + ".xml";
    }

    public void setParametersFile(String parametersFile)
    {
        _parametersFile = parametersFile;
    }

    @Override
    public String[] getInputExtensions()
    {
        return _inputExtensions;
    }

    public void setInputExtensions(String... inputExtensions)
    {
        _inputExtensions = inputExtensions;
    }

    @Override
    public String[] getOutputExtensions()
    {
        return _outputExtensions;
    }

    public void setOutputExtensions(String... outputExtensions)
    {
        _outputExtensions = outputExtensions;
    }

    @Override
    public String getRunKey()
    {
        return _dataPath + " (" + _protocolType + "/" + _protocolName + ")";
    }

    public String getDirStatusDesciption()
    {
        return getDataDirName() + " (" + _protocolName + ")";
    }

    @Override
    public String[] getExperimentLinks()
    {
        if (_experimentLinks == null)
        {
            String[] dirs = _dataPath.split("/");
            String dataDirName = dirs[dirs.length - 1];

            if (_sampleNames.length == 0)
                _experimentLinks = new String[] { dataDirName + " (" + _protocolName + ")" };
            else
            {
                ArrayList<String> listLinks = new ArrayList<>();
                for (String name : _sampleNames)
                    listLinks.add(dataDirName + '/' + name + " (" + _protocolName + ")");
                _experimentLinks = listLinks.toArray(new String[listLinks.size()]);
            }
        }
        return _experimentLinks;
    }

    @Override
    public void setExperimentLinks(String[] experimentLinks)
    {
        _experimentLinks = experimentLinks;
    }

    @Override
    public PipelineFolder.MailSettings getMailSettings()
    {
        return _mailSettings;
    }

    @Override
    public void setMailSettings(PipelineFolder.MailSettings mailSettings)
    {
        _mailSettings = mailSettings;
    }

    @Override
    public boolean isExpectError()
    {
        return _expectError;
    }

    @Override
    public void setExpectError(boolean expectError)
    {
        _expectError = expectError;
    }

    @Override
    public void validate()
    {
        if (_mailSettings != null)
        {
            if (_expectError)
                validateEmailError();
            else
                validateEmailSuccess();
        }
        else
        {
            // Default fails to allow manual analysis of the run.
            // Override to do actual automated validation of the resulting
            // MS2 run data.

            validateTrue("No automated validation", false);
        }
    }

    @Override
    public void validateTrue(String message, boolean condition)
    {
        if (!condition)
        {
            _test.log("INVALID: " + message);
            _valid = false;
        }
    }

    @Override
    public boolean isValid()
    {
        return _valid;
    }

    @Override
    public void verifyClean(File rootDir)
    {
        File analysisDir = new File(rootDir, getDataPath() + File.separatorChar + getProtocolType());
        if (analysisDir.exists())
            fail("Pipeline files were not cleaned up; "+ analysisDir.toString() + " directory still exists");
    }

    @Override
    public void clean(File rootDir)
    {
        TestFileUtils.delete(new File(new File(rootDir, getDataPath()), getProtocolType()));
    }

    @Override
    public void startProcessing()
    {
        _test.log("Start analysis of " + getDataPath());
        _test.clickButton("Process and Import Data");
        _test._fileBrowserHelper.selectFileBrowserItem(getDataPath()+"/");

        clickActionButton();

        int wait = BaseWebDriverTest.WAIT_FOR_JAVASCRIPT;
        _test.log("Choose existing protocol " + getProtocolName());
        _test.waitForElement(Locator.xpath("//select[@name='protocol']/option[.='" + getProtocolName() + "']" ), wait*12); // seems very long
        _test.selectOptionByText(Locator.name("protocol"), getProtocolName());
        WebDriverWrapper.sleep(wait);

        _test.log("Start data processing");
        clickSubmitButton();
        WebDriverWrapper.sleep(wait);
    }

    protected abstract void clickSubmitButton();

    @Override
    public void remove()
    {
        ExperimentRunTable tableExp = getExperimentRunTable();

        for (String name : getExperimentLinks())
        {
            _test.log("Removing " + name);

            _test.pushLocation();
            tableExp.clickGraphLink(name);
            String id = _test.getURL().getQuery();
            id = id.substring(id.indexOf('=') + 1);
            _test.popLocation();

            _test.checkCheckbox(Locator.checkboxByNameAndValue(".select", id));
            _test.clickButton("Delete");
            _test.clickButton("Confirm Delete");
        }
    }

    private ExperimentRunTable getExperimentRunTable()
    {
        return new ExperimentRunTable(getExperimentRunTableName(), _test, false);
    }
    
    private void validateExperiment()
    {
        _test.clickButton("Data");
        ExperimentGraph graph = new ExperimentGraph(_test);
        graph.validate(this);
    }

    public void validateEmailSuccess()
    {
        assertNotNull("Email validation requires mail settings", _mailSettings);

        validateEmail("COMPLETE", getDirStatusDesciption(), _mailSettings.isNotifyOnSuccess(),
                _mailSettings.getNotifyUsersOnSuccess());

        if (_test.isButtonPresent("Data"))
        {
            validateExperiment();
        }
        else
        {
            int split = 1;
            while (_test.isElementPresent(Locator.linkWithText("COMPLETE").index(split)))
            {
                _test.pushLocation();
                Integer index = split++;
                _test.clickAndWait(Locator.linkWithText("COMPLETE").index(index));
                validateExperiment();
                _test.popLocation();
            }
        }
    }

    public void validateEmailError()
    {
        assertNotNull("Email validation requires mail settings", _mailSettings);

        for (String sampleExp : getExperimentLinks())
        {
            _test.pushLocation();
            validateEmail("ERROR", sampleExp, _mailSettings.isNotifyOnError(),
                    _mailSettings.getNotifyUsersOnError());
            _test.popLocation();
        }
    }

    private void validateEmail(String status, String description, boolean notifyOwner, String[] notifyOthers)
    {
        if (!notifyOwner && notifyOthers.length == 0)
            return; // No email expected.

        String ownerEmail = PasswordUtil.getUsername();
        EmailRecordTable emailTable = new EmailRecordTable(_test);
        EmailRecordTable.EmailMessage message = emailTable.getMessageWithSubjectContaining(description);
        assertNotNull("No email message found for " + description, message);
        emailTable.clickMessage(message);
        // Refetch message after expanding to get entire message text
        message = emailTable.getMessageWithSubjectContaining(description);
        validateTrue("The test " + description + " does not have expected status " + status,
                message.getBody().contains("Status: " + status));
        List<String> recipients = Arrays.asList(message.getTo());
        if (notifyOwner)
        {
            validateTrue("Message not sent to owner " + ownerEmail, recipients.contains(ownerEmail));
        }
        for (String notify : notifyOthers)
        {
            validateTrue("Message not sent to " + notify, recipients.contains(notify));
        }

        assertTrue("Could not find link in message with Status: '" + status + "' and Description: '" + description + "'", clickLink(message));

        // Make sure we made it to a status page.
        _test.assertTextPresent("Job Status", status);
    }

    private boolean clickLink(EmailRecordTable.EmailMessage message)
    {
        // The link in this message uses the IP address.  Avoid clicking it, and
        // possibly changing hostnames.
        for (String line : StringUtils.split(message.getBody(), "\n"))
        {
            if (line.startsWith("http://"))
            {
                _test.beginAt(line.substring(line.indexOf('/', 7)));
                return true;
            }
            if (line.startsWith("https://"))
            {
                _test.beginAt(line.substring(line.indexOf('/', 8)));
                return true;
            }
        }
        return false;
    }

}
